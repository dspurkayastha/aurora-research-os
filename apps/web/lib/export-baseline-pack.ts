import type {
  BaselineBuildResult,
  RegistryFieldMapping,
  ValidationIssue,
} from "@aurora/core";

const CORE_DISCLAIMER =
  "Draft generated by Aurora Research OS deterministic engine (India v1 profile). Requires review and approval by the Principal Investigator and Institutional Ethics Committee. Does not constitute legal, ethical, or regulatory approval.";

function escapeXml(value: string): string {
  return value
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}

function buildParagraph(text: string): string {
  const safe = escapeXml(text);
  return `<w:p><w:r><w:t>${safe}</w:t></w:r></w:p>`;
}

function splitContent(content: string): string[] {
  return content
    .split(/\n+/)
    .map((line) => line.trim())
    .filter((line) => line.length > 0);
}

type DocSection = {
  heading: string;
  body: string[];
};

function createDocxDocument(title: string, sections: DocSection[], footer: string[]): Uint8Array {
  const now = new Date().toISOString();
  const bodyParagraphs: string[] = [buildParagraph(title)];

  for (const section of sections) {
    bodyParagraphs.push(buildParagraph(section.heading));
    for (const paragraph of section.body) {
      bodyParagraphs.push(buildParagraph(paragraph));
    }
  }

  for (const line of footer) {
    bodyParagraphs.push(buildParagraph(line));
  }

  const documentXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:body>
    ${bodyParagraphs.join("\n    ")}
    <w:sectPr>
      <w:pgSz w:w="12240" w:h="15840"/>
      <w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440" w:header="720" w:footer="720" w:gutter="0"/>
    </w:sectPr>
  </w:body>
</w:document>`;

  const contentTypes = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>
  <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>
</Types>`;

  const rootRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="R1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
  <Relationship Id="R2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>
  <Relationship Id="R3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>
</Relationships>`;

  const docRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"/>`;

  const coreProps = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <dc:title>${escapeXml(title)}</dc:title>
  <dc:creator>Aurora Research OS</dc:creator>
  <cp:lastModifiedBy>Aurora Research OS</cp:lastModifiedBy>
  <dcterms:created xsi:type="dcterms:W3CDTF">${now}</dcterms:created>
  <dcterms:modified xsi:type="dcterms:W3CDTF">${now}</dcterms:modified>
</cp:coreProperties>`;

  const appProps = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">
  <Application>Aurora Research OS</Application>
</Properties>`;

  const entries: ZipEntry[] = [
    { name: "[Content_Types].xml", data: Buffer.from(contentTypes, "utf8") },
    { name: "_rels/.rels", data: Buffer.from(rootRels, "utf8") },
    { name: "word/document.xml", data: Buffer.from(documentXml, "utf8") },
    { name: "word/_rels/document.xml.rels", data: Buffer.from(docRels, "utf8") },
    { name: "docProps/core.xml", data: Buffer.from(coreProps, "utf8") },
    { name: "docProps/app.xml", data: Buffer.from(appProps, "utf8") },
  ];

  return createZip(entries);
}

function buildProtocolDoc(baseline: BaselineBuildResult): Uint8Array {
  const overviewSection: DocSection = {
    heading: "Study Overview",
    body: [
      `Rulebook profile: ${baseline.versionInfo.rulebookProfile}`,
      `Rulebook version: ${baseline.versionInfo.rulebookVersion}`,
      `Generated at: ${baseline.versionInfo.generatedAt}`,
      `Study design: ${baseline.studySpec.designLabel ?? "Pending classification"}`,
      `Primary endpoint: ${baseline.studySpec.primaryEndpoint?.name ?? "To be defined"}`,
    ],
  };

  const sections: DocSection[] = [overviewSection];
  for (const section of baseline.protocol.sections) {
    sections.push({ heading: section.title, body: splitContent(section.content) });
  }

  const footer = [baseline.disclaimer, CORE_DISCLAIMER];
  return createDocxDocument(baseline.protocol.title, sections, footer);
}

function buildEndpointDescription(baseline: BaselineBuildResult): string[] {
  if (!baseline.sap.endpoints || baseline.sap.endpoints.length === 0) {
    return ["Endpoint analysis pending statistician confirmation."];
  }

  return baseline.sap.endpoints.map((endpoint: any) => {
    const parts = [endpoint.testOrModel];
    if (endpoint.effectMeasure) parts.push(`Effect measure: ${endpoint.effectMeasure}`);
    if (endpoint.estimand) parts.push(`Estimand: ${endpoint.estimand}`);
    if (endpoint.covariates && endpoint.covariates.length > 0) {
      parts.push(`Covariates: ${endpoint.covariates.join(", ")}`);
    }
    if (endpoint.missingDataApproach) parts.push(`Missing data: ${endpoint.missingDataApproach}`);
    return `${endpoint.role.toUpperCase()}: ${endpoint.endpointName} — ${parts.join("; ")}`;
  });
}

function buildSapDoc(baseline: BaselineBuildResult): Uint8Array {
  const sections: DocSection[] = [
    {
      heading: `${baseline.studySpec.title} — Statistical Analysis Plan (Draft)`,
      body: [
        `Linked protocol version: ${baseline.protocol.versionTag}`,
        `Sample size summary: ${baseline.sapExplanation.sampleSizeSummary}`,
      ],
    },
    {
      heading: "Analysis Sets",
      body: [
        baseline.sap.analysisSets.fullAnalysisSet,
        baseline.sap.analysisSets.perProtocolSet ?? "",
        baseline.sap.analysisSets.safetySet ?? "",
      ].filter(Boolean),
    },
    { heading: "Endpoints", body: buildEndpointDescription(baseline) },
    { heading: "Multiplicity", body: [baseline.sap.multiplicity] },
    { heading: "Interim Analysis", body: [baseline.sap.interimAnalysis] },
    {
      heading: "Subgroup & Sensitivity",
      body: [baseline.sap.subgroupAnalyses, baseline.sap.sensitivityAnalyses].filter(Boolean),
    },
    { heading: "Missing Data", body: [baseline.sap.missingDataGeneral] },
    { heading: "Software", body: [baseline.sap.software] },
  ];

  const footer = [baseline.disclaimer, CORE_DISCLAIMER];
  return createDocxDocument(`${baseline.studySpec.title} — SAP`, sections, footer);
}

function buildPisDoc(baseline: BaselineBuildResult): Uint8Array {
  const sections: DocSection[] = [
    {
      heading: `${baseline.studySpec.title} — Participant Information & Consent Draft`,
      body: ["This draft aligns with ICMR consent elements and requires site customisation."],
    },
  ];

  for (const clause of baseline.pisIcf.sections) {
    sections.push({ heading: clause.title, body: splitContent(clause.content) });
  }

  const footer = [
    "This consent draft must be adapted to the institution's IEC-approved template.",
    baseline.disclaimer,
    CORE_DISCLAIMER,
  ];
  return createDocxDocument(`${baseline.studySpec.title} — PIS/ICF`, sections, footer);
}

function buildIecDoc(baseline: BaselineBuildResult): Uint8Array {
  const sections: DocSection[] = [
    { heading: "Summary", body: splitContent(baseline.iecCoverNote.summary) },
    { heading: "Design & Methods", body: splitContent(baseline.iecCoverNote.designAndMethods) },
    { heading: "Risk-Benefit", body: splitContent(baseline.iecCoverNote.riskBenefit) },
    {
      heading: "Ethics Highlights",
      body: splitContent(baseline.iecCoverNote.keyEthicsHighlights),
    },
    {
      heading: "Attachments",
      body:
        baseline.iecCoverNote.attachmentsList.length > 0
          ? baseline.iecCoverNote.attachmentsList
          : ["Protocol, SAP, PIS/ICF, CRF schema, regulatory checklist, registry mapping."],
    },
  ];

  if (baseline.iecCoverNote.warnings.length > 0) {
    sections.push({ heading: "Warnings", body: baseline.iecCoverNote.warnings });
  }

  const footer = [baseline.disclaimer, CORE_DISCLAIMER];
  return createDocxDocument(`${baseline.studySpec.title} — IEC Cover Note`, sections, footer);
}

function buildRegistryCsv(fields: RegistryFieldMapping[]): string {
  const header = "field_id,label,value,source,notes";
  const rows = fields.map((field) =>
    [field.fieldId, field.label, field.value ?? "", field.source, field.notes ?? ""].map((value) => {
      const escaped = `${value}`.replace(/"/g, '""');
      return `"${escaped}"`;
    })
  );
  return [header, ...rows.map((columns) => columns.join(",")), `"","","${CORE_DISCLAIMER}","",""]`].join("\n");
}

function buildRegulatoryChecklistMarkdown(baseline: BaselineBuildResult): string {
  const lines = ["# Regulatory Checklist (Draft)", "", "Status legend: ok / needs-review / missing", ""]; 
  for (const item of baseline.regulatoryChecklist.items) {
    const note = item.notes ? ` — ${item.notes}` : "";
    lines.push(`- [${item.status}] ${item.label} (${item.scope}) — severity: ${item.severity}${note}`);
  }
  lines.push("", baseline.disclaimer, "", CORE_DISCLAIMER);
  return lines.join("\n");
}

function buildLiteratureMarkdown(baseline: BaselineBuildResult): string {
  const lines = ["# Literature Review Plan", "", baseline.literaturePlan.picoSummary, "", "## Suggested keywords", ""];
  for (const keyword of baseline.literaturePlan.suggestedKeywords) {
    lines.push(`- ${keyword}`);
  }
  lines.push("", "## Notes", "");
  for (const note of baseline.literaturePlan.notes) {
    lines.push(`- ${note}`);
  }
  lines.push("", baseline.disclaimer, "", CORE_DISCLAIMER);
  return lines.join("\n");
}

function buildCrfJson(baseline: BaselineBuildResult): string {
  return JSON.stringify(
    {
      ...baseline.crf,
      disclaimer: CORE_DISCLAIMER,
    },
    null,
    2
  );
}

type ZipEntry = { name: string; data: Uint8Array };

const CRC_TABLE = (() => {
  const table = new Uint32Array(256);
  for (let n = 0; n < 256; n += 1) {
    let c = n;
    for (let k = 0; k < 8; k += 1) {
      if (c & 1) {
        c = 0xedb88320 ^ (c >>> 1);
      } else {
        c >>>= 1;
      }
    }
    table[n] = c >>> 0;
  }
  return table;
})();

function crc32(buffer: Uint8Array): number {
  let crc = 0 ^ -1;
  for (let i = 0; i < buffer.length; i += 1) {
    const byte = buffer[i];
    crc = (crc >>> 8) ^ CRC_TABLE[(crc ^ byte) & 0xff];
  }
  return (crc ^ -1) >>> 0;
}

function concatArrays(arrays: Uint8Array[]): Uint8Array {
  const total = arrays.reduce((sum, part) => sum + part.length, 0);
  const merged = new Uint8Array(total);
  let offset = 0;
  for (const part of arrays) {
    merged.set(part, offset);
    offset += part.length;
  }
  return merged;
}

function createZip(entries: ZipEntry[]): Uint8Array {
  const localParts: Uint8Array[] = [];
  const centralParts: Uint8Array[] = [];
  let offset = 0;

  for (const entry of entries) {
    const nameBytes = Buffer.from(entry.name, "utf8");
    const data = entry.data instanceof Uint8Array ? entry.data : new Uint8Array(entry.data);
    const crc = crc32(data);

    const localHeader = new Uint8Array(30 + nameBytes.length);
    const localView = new DataView(localHeader.buffer);
    localView.setUint32(0, 0x04034b50, true);
    localView.setUint16(4, 20, true);
    localView.setUint16(6, 0, true);
    localView.setUint16(8, 0, true);
    localView.setUint16(10, 0, true);
    localView.setUint16(12, 0, true);
    localView.setUint32(14, crc, true);
    localView.setUint32(18, data.length, true);
    localView.setUint32(22, data.length, true);
    localView.setUint16(26, nameBytes.length, true);
    localView.setUint16(28, 0, true);
    localHeader.set(nameBytes, 30);

    localParts.push(localHeader, data);

    const centralHeader = new Uint8Array(46 + nameBytes.length);
    const centralView = new DataView(centralHeader.buffer);
    centralView.setUint32(0, 0x02014b50, true);
    centralView.setUint16(4, 20, true);
    centralView.setUint16(6, 20, true);
    centralView.setUint16(8, 0, true);
    centralView.setUint16(10, 0, true);
    centralView.setUint16(12, 0, true);
    centralView.setUint16(14, 0, true);
    centralView.setUint32(16, crc, true);
    centralView.setUint32(20, data.length, true);
    centralView.setUint32(24, data.length, true);
    centralView.setUint16(28, nameBytes.length, true);
    centralView.setUint16(30, 0, true);
    centralView.setUint16(32, 0, true);
    centralView.setUint16(34, 0, true);
    centralView.setUint16(36, 0, true);
    centralView.setUint32(38, 0, true);
    centralView.setUint32(42, offset, true);
    centralHeader.set(nameBytes, 46);

    centralParts.push(centralHeader);

    offset += localHeader.length + data.length;
  }

  const centralDirectory = concatArrays(centralParts);
  const end = new Uint8Array(22);
  const endView = new DataView(end.buffer);
  endView.setUint32(0, 0x06054b50, true);
  endView.setUint16(4, 0, true);
  endView.setUint16(6, 0, true);
  endView.setUint16(8, entries.length, true);
  endView.setUint16(10, entries.length, true);
  endView.setUint32(12, centralDirectory.length, true);
  endView.setUint32(16, offset, true);
  endView.setUint16(20, 0, true);

  return concatArrays([...localParts, centralDirectory, end]);
}

export async function buildBaselinePackZip(baseline: BaselineBuildResult): Promise<Uint8Array> {
  const files: ZipEntry[] = [
    { name: "01_Protocol.docx", data: buildProtocolDoc(baseline) },
    { name: "02_SAP.docx", data: buildSapDoc(baseline) },
    { name: "03_PIS_ICF.docx", data: buildPisDoc(baseline) },
    { name: "04_IEC_Cover_Note.docx", data: buildIecDoc(baseline) },
    { name: "05_CRF_Spec.json", data: Buffer.from(buildCrfJson(baseline), "utf8") },
    { name: "06_Registry_Mapping.csv", data: Buffer.from(buildRegistryCsv(baseline.registryMapping.fields), "utf8") },
    { name: "07_Regulatory_Checklist.md", data: Buffer.from(buildRegulatoryChecklistMarkdown(baseline), "utf8") },
    { name: "08_Literature_Plan.md", data: Buffer.from(buildLiteratureMarkdown(baseline), "utf8") },
  ];

  return createZip(files);
}

export function getBlockingIssues(baseline: BaselineBuildResult): ValidationIssue[] {
  return baseline.issues.filter((issue: any) => issue.severity === "critical");
}

