import type { BaselineBuildResult } from "@aurora/core";

type BinaryBuffer = any;

const DRAFT_FOOTER =
  "Draft generated by Aurora Research OS. Requires review and approval by Principal Investigator and Ethics Committee.";

function escapeXml(value: string): string {
  return value
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}

function buildParagraph(text: string): string {
  const escaped = escapeXml(text);
  return `<w:p><w:r><w:t>${escaped}</w:t></w:r></w:p>`;
}

function createDocxDocument(title: string, sections: { heading: string; body: string[] }[]): BinaryBuffer {
  const now = new Date().toISOString();
  const bodyParagraphs: string[] = [buildParagraph(title)];
  for (const section of sections) {
    bodyParagraphs.push(buildParagraph(section.heading));
    for (const paragraph of section.body) {
      bodyParagraphs.push(buildParagraph(paragraph));
    }
  }
  bodyParagraphs.push(buildParagraph(DRAFT_FOOTER));

  const documentXml = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
  <w:body>
    ${bodyParagraphs.join("\n    ")}
    <w:sectPr>
      <w:pgSz w:w="12240" w:h="15840"/>
      <w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440" w:header="720" w:footer="720" w:gutter="0"/>
    </w:sectPr>
  </w:body>
</w:document>`;

  const contentTypes = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="xml" ContentType="application/xml"/>
  <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
  <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/>
  <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/>
</Types>`;

  const rootRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Id="R1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
  <Relationship Id="R2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>
  <Relationship Id="R3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>
</Relationships>`;

  const docRels = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"/>`;

  const coreProps = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <dc:title>${escapeXml(title)}</dc:title>
  <dc:creator>Aurora Research OS</dc:creator>
  <cp:lastModifiedBy>Aurora Research OS</cp:lastModifiedBy>
  <dcterms:created xsi:type="dcterms:W3CDTF">${now}</dcterms:created>
  <dcterms:modified xsi:type="dcterms:W3CDTF">${now}</dcterms:modified>
</cp:coreProperties>`;

  const appProps = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">
  <Application>Aurora Research OS</Application>
</Properties>`;

  const docEntries: ZipEntry[] = [
    { name: "[Content_Types].xml", data: Buffer.from(contentTypes, "utf8") },
    { name: "_rels/.rels", data: Buffer.from(rootRels, "utf8") },
    { name: "word/document.xml", data: Buffer.from(documentXml, "utf8") },
    { name: "word/_rels/document.xml.rels", data: Buffer.from(docRels, "utf8") },
    { name: "docProps/core.xml", data: Buffer.from(coreProps, "utf8") },
    { name: "docProps/app.xml", data: Buffer.from(appProps, "utf8") },
  ];

  return createZip(docEntries);
}

function buildProtocolDoc(baseline: BaselineBuildResult): BinaryBuffer {
  const sections = baseline.protocol.sections.map((section) => ({
    heading: section.title,
    body: [section.content],
  }));
  return createDocxDocument(baseline.protocol.title ?? "Protocol", sections);
}

function buildSapDoc(baseline: BaselineBuildResult): BinaryBuffer {
  const sections = [
    {
      heading: "Analysis Sets",
      body: [
        baseline.sap.analysisSets.fullAnalysisSet,
        baseline.sap.analysisSets.perProtocolSet ?? "",
        baseline.sap.analysisSets.safetySet ?? "",
      ].filter(Boolean),
    },
    {
      heading: "Endpoints",
      body:
        baseline.sap.endpoints.length > 0
          ? baseline.sap.endpoints.map(
              (endpoint) =>
                `${endpoint.role.toUpperCase()}: ${endpoint.endpointName} — ${endpoint.testOrModel}. Effect measure: ${
                  endpoint.effectMeasure ?? "Not specified"
                }.`
            )
          : ["Endpoint analysis pending statistician confirmation."],
    },
    { heading: "Multiplicity", body: [baseline.sap.multiplicity] },
    { heading: "Interim Analysis", body: [baseline.sap.interimAnalysis] },
    { heading: "Subgroup & Sensitivity", body: [baseline.sap.subgroupAnalyses, baseline.sap.sensitivityAnalyses].filter(Boolean) },
    { heading: "Missing Data", body: [baseline.sap.missingDataGeneral] },
    { heading: "Software", body: [baseline.sap.software] },
    { heading: "Sample Size Summary", body: [baseline.sapExplanation.sampleSizeSummary] },
  ];
  return createDocxDocument(`${baseline.studySpec.title ?? "Study"} SAP`, sections);
}

function buildPisDoc(baseline: BaselineBuildResult): BinaryBuffer {
  const sections = baseline.pisIcf.sections.map((section) => ({
    heading: section.title,
    body: [section.content],
  }));
  return createDocxDocument(`${baseline.studySpec.title ?? "Study"} PIS-ICF`, sections);
}

function buildIecDoc(baseline: BaselineBuildResult): BinaryBuffer {
  const sections = [
    { heading: "Summary", body: [baseline.iecCoverNote.summary] },
    { heading: "Design & Methods", body: [baseline.iecCoverNote.designAndMethods] },
    { heading: "Risk-Benefit", body: [baseline.iecCoverNote.riskBenefit] },
    { heading: "Ethics Highlights", body: [baseline.iecCoverNote.keyEthicsHighlights] },
    { heading: "Attachments", body: baseline.iecCoverNote.attachmentsList },
  ];
  return createDocxDocument(`${baseline.studySpec.title ?? "Study"} IEC Note`, sections);
}

function buildRegulatoryChecklistMarkdown(baseline: BaselineBuildResult): string {
  const lines = ["# Regulatory Checklist (Draft)", "", "Status legend: ok / needs-review / missing", ""];
  for (const item of baseline.regulatoryChecklist.items) {
    lines.push(`- [${item.status}] ${item.label} (${item.scope}) — severity: ${item.severity}${
      item.notes ? ` — ${item.notes}` : ""
    }`);
  }
  lines.push("", DRAFT_FOOTER);
  return lines.join("\n");
}

function buildRegistryCsv(baseline: BaselineBuildResult): string {
  const header = "fieldId,label,value,source,notes";
  const rows = baseline.registryMapping.fields.map((field) =>
    [field.fieldId, field.label, field.value ?? "", field.source, field.notes ?? ""].map((value) => {
      const escaped = `${value}`.replace(/"/g, '""');
      return `"${escaped}"`;
    })
  );
  return [header, ...rows.map((columns) => columns.join(",")), "", `"","","${DRAFT_FOOTER}","",""]`].join("\n");
}

function buildLiteratureMarkdown(baseline: BaselineBuildResult): string {
  const lines = ["# Literature Review Plan", "", baseline.literaturePlan.picoSummary, "", "## Suggested keywords", ""];
  for (const keyword of baseline.literaturePlan.suggestedKeywords) {
    lines.push(`- ${keyword}`);
  }
  lines.push("", "## Notes", "");
  for (const note of baseline.literaturePlan.notes) {
    lines.push(`- ${note}`);
  }
  lines.push("", DRAFT_FOOTER);
  return lines.join("\n");
}

interface ZipEntry {
  name: string;
  data: BinaryBuffer;
}

const CRC_TABLE = (() => {
  const table = new Uint32Array(256);
  for (let n = 0; n < 256; n += 1) {
    let c = n;
    for (let k = 0; k < 8; k += 1) {
      if (c & 1) {
        c = 0xedb88320 ^ (c >>> 1);
      } else {
        c >>>= 1;
      }
    }
    table[n] = c >>> 0;
  }
  return table;
})();

function crc32(buffer: BinaryBuffer): number {
  let crc = 0 ^ -1;
  for (let i = 0; i < buffer.length; i += 1) {
    const byte = buffer[i];
    crc = (crc >>> 8) ^ CRC_TABLE[(crc ^ byte) & 0xff];
  }
  return (crc ^ -1) >>> 0;
}

function createZip(entries: ZipEntry[]): BinaryBuffer {
  const localParts: BinaryBuffer[] = [];
  const centralParts: BinaryBuffer[] = [];
  let offset = 0;

  for (const entry of entries) {
    const nameBuffer = Buffer.from(entry.name, "utf8");
    const data = entry.data;
    const crc = crc32(data);

    const localHeader = Buffer.alloc(30 + nameBuffer.length);
    localHeader.writeUInt32LE(0x04034b50, 0);
    localHeader.writeUInt16LE(20, 4);
    localHeader.writeUInt16LE(0, 6);
    localHeader.writeUInt16LE(0, 8);
    localHeader.writeUInt16LE(0, 10);
    localHeader.writeUInt16LE(0, 12);
    localHeader.writeUInt32LE(crc, 14);
    localHeader.writeUInt32LE(data.length, 18);
    localHeader.writeUInt32LE(data.length, 22);
    localHeader.writeUInt16LE(nameBuffer.length, 26);
    localHeader.writeUInt16LE(0, 28);
    nameBuffer.copy(localHeader, 30);

    localParts.push(localHeader, data);

    const centralHeader = Buffer.alloc(46 + nameBuffer.length);
    centralHeader.writeUInt32LE(0x02014b50, 0);
    centralHeader.writeUInt16LE(20, 4);
    centralHeader.writeUInt16LE(20, 6);
    centralHeader.writeUInt16LE(0, 8);
    centralHeader.writeUInt16LE(0, 10);
    centralHeader.writeUInt16LE(0, 12);
    centralHeader.writeUInt16LE(0, 14);
    centralHeader.writeUInt32LE(crc, 16);
    centralHeader.writeUInt32LE(data.length, 20);
    centralHeader.writeUInt32LE(data.length, 24);
    centralHeader.writeUInt16LE(nameBuffer.length, 28);
    centralHeader.writeUInt16LE(0, 30);
    centralHeader.writeUInt16LE(0, 32);
    centralHeader.writeUInt16LE(0, 34);
    centralHeader.writeUInt16LE(0, 36);
    centralHeader.writeUInt32LE(0, 38);
    centralHeader.writeUInt32LE(offset, 42);
    nameBuffer.copy(centralHeader, 46);

    centralParts.push(centralHeader);

    offset += localHeader.length + data.length;
  }

  const centralDirectorySize = centralParts.reduce((total, part) => total + part.length, 0);
  const endOfCentralDirectory = Buffer.alloc(22);
  endOfCentralDirectory.writeUInt32LE(0x06054b50, 0);
  endOfCentralDirectory.writeUInt16LE(0, 4);
  endOfCentralDirectory.writeUInt16LE(0, 6);
  endOfCentralDirectory.writeUInt16LE(entries.length, 8);
  endOfCentralDirectory.writeUInt16LE(entries.length, 10);
  endOfCentralDirectory.writeUInt32LE(centralDirectorySize, 12);
  endOfCentralDirectory.writeUInt32LE(offset, 16);
  endOfCentralDirectory.writeUInt16LE(0, 20);

  return Buffer.concat([...localParts, ...centralParts, endOfCentralDirectory]);
}

export function buildBaselineZip(baseline: BaselineBuildResult): BinaryBuffer {
  const files: ZipEntry[] = [
    { name: "protocol.docx", data: buildProtocolDoc(baseline) },
    { name: "sap.docx", data: buildSapDoc(baseline) },
    { name: "pis-icf.docx", data: buildPisDoc(baseline) },
    { name: "iec-cover-note.docx", data: buildIecDoc(baseline) },
    { name: "crf-schema.json", data: Buffer.from(JSON.stringify(baseline.crf, null, 2), "utf8") },
    { name: "study-spec.json", data: Buffer.from(JSON.stringify(baseline.studySpec, null, 2), "utf8") },
    { name: "sample-size.json", data: Buffer.from(JSON.stringify(baseline.sampleSize, null, 2), "utf8") },
    { name: "regulatory-checklist.md", data: Buffer.from(buildRegulatoryChecklistMarkdown(baseline), "utf8") },
    { name: "registry-mapping.csv", data: Buffer.from(buildRegistryCsv(baseline), "utf8") },
    { name: "literature-plan.md", data: Buffer.from(buildLiteratureMarkdown(baseline), "utf8") },
  ];

  return createZip(files);
}
