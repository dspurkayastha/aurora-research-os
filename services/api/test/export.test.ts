import test from "node:test";
import assert from "node:assert/strict";

import {
  buildBaselinePackageFromIdea,
  canLockAndLaunch,
} from "@aurora/core";
import type { SampleSizeAssumptionsBase } from "@aurora/core";

import { buildBaselineZip } from "../src/export";

const idea =
  "We want to study 30-day mortality after emergency laparotomy in adult patients at our tertiary care hospital.";

const assumptions: Partial<SampleSizeAssumptionsBase> = {
  alpha: 0.05,
  power: 0.8,
  twoSided: true,
  hypothesisType: "superiority",
  designId: "rct-2arm-parallel",
  primaryEndpointType: "binary",
  expectedControlEventRate: 0.3,
  expectedTreatmentEventRate: 0.18,
};

type ZipEntries = Map<string, any>;

function parseZip(buffer: any): ZipEntries {
  const entries = new Map<string, any>();
  let offset = 0;
  const signature = 0x04034b50;

  while (offset + 30 < buffer.length) {
    const header = buffer.readUInt32LE(offset);
    if (header !== signature) {
      break;
    }

    const nameLength = buffer.readUInt16LE(offset + 26);
    const extraLength = buffer.readUInt16LE(offset + 28);
    const compressedSize = buffer.readUInt32LE(offset + 18);
    const nameStart = offset + 30;
    const nameEnd = nameStart + nameLength;
    const dataStart = nameEnd + extraLength;
    const dataEnd = dataStart + compressedSize;
    const name = buffer.slice(nameStart, nameEnd).toString("utf8");
    const data = buffer.slice(dataStart, dataEnd);

    entries.set(name, data);
    offset = dataEnd;
  }

  return entries;
}

test("baseline zip bundles deterministic documents with disclaimers", () => {
  const baseline = buildBaselinePackageFromIdea(idea, assumptions);
  const zip = buildBaselineZip(baseline);
  assert.ok(zip.length > 0, "zip output should be non-empty");

  const entries = parseZip(zip);
  const expectedFiles = [
    "protocol.docx",
    "sap.docx",
    "pis-icf.docx",
    "iec-cover-note.docx",
    "crf-schema.json",
    "study-spec.json",
    "sample-size.json",
    "regulatory-checklist.md",
    "registry-mapping.csv",
    "literature-plan.md",
  ];

  for (const file of expectedFiles) {
    assert.ok(entries.has(file), `missing ${file} in baseline pack`);
  }

  const protocolDoc = entries.get("protocol.docx");
  const protocolEntries = parseZip(protocolDoc);
  const documentXml = protocolEntries.get("word/document.xml");
  assert.ok(documentXml, "protocol docx must include document.xml");
  const xmlText = documentXml.toString("utf8");
  assert.match(xmlText, /Draft generated by Aurora Research OS/);
  assert.match(xmlText, /Sample Size/);

  const checklistMarkdown = entries.get("regulatory-checklist.md").toString("utf8");
  assert.match(checklistMarkdown, /Regulatory Checklist/);
  assert.match(checklistMarkdown, /Draft generated by Aurora Research OS/);

  const registryCsv = entries.get("registry-mapping.csv").toString("utf8");
  assert.match(registryCsv, /ctri_public_title/);
});

test("compliance gate blocks packs with blocking issues", () => {
  const baseline = buildBaselinePackageFromIdea("Observational audit", {} as any);
  const gate = canLockAndLaunch(baseline);
  assert.equal(typeof gate.allowed, "boolean");
  if (gate.allowed) {
    assert.ok(gate.blockingIssues.length === 0);
  } else {
    assert.ok(gate.blockingIssues.length >= 0);
  }
});
